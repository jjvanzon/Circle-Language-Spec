Encircle Language | Broader View
================================

`[ Preliminary documentation ]`

These are various draft texts that may once describe a story, ideas about how this Encircle language might be used in practice.

- ## [Exchangeability](exchangeability)

    - The *Exchangeability Principles* describes things in the area of computer technology, that are traditionally separate, that might be combined to form one thing.
    - Perhaps the most important goal of the Encircle programming language, is to melt together all computer technology disciplines, providing one clear language, that can express anything, and that everybody can understand. The *Exchangeability Principles* might make a lot of promises about the new language.

- ## [Expression](expression)

    - This part of the documentation may cover remaining topics about the diagram expression.  
     
    - The idea behind expression in general is that a program’s systematics might not be described by text code, but text code as well as the diagram notation may be mere *expressions* of systematics, stored in some other way, for instance a binary way as interlinked objects.
    
    - The diagram might be fully automatically drawn out. The metrics and positioning of the shapes and lines might get automatically determined. The diagram can be edited, which may result in changes to the stored objects.

    - Text code and diagram expression can be complemented by any other form of expression. Displaying data in tabular form is another form of expression. Expressing data and commands in a graphical windows user interface is also an alternative form of expression of systematics. Furthermore, certain objects have specialized expressions. For instance a sound object may be expressed by playing its sound, but not all objects can be expressed by playing it as sound. All expressions are considered alternative expressions of systematics, just like text code and diagram code.
    
    - Much of this documentation folder is a mere throw-together of ideas or pieces of text, that came out of previous descriptions of new computer programming languages.  

- ## [Extensibility](extensibility)
 
    - Perhaps the most important goal of the Encircle programming language, is to melt together all computer technology disciplines, providing one clear language, that can express anything, and that everybody can understand. The *Extensibility Principles* may make a lot of promises about the new language.
    - The *extensibility principles* may cover the techniques that make sure existing software is extensible and make sure, that *Encircle language* may integrate with the rest of the world of computer technology. *Encircle* resources might be accessible to other systems and existing resources on the internet might be accessible in *Encircle*.

- ## [From Spec](from-spec)

    - Topics that may be recognizable from the *spec*, but then ideas perhaps less to the point but more philosophical.

- ## [Integration](integration)

    - Encircle language might be a candidate for a different way to operate computers. This folder will contain any documentation about integration modules, that *Encircle* has to offer in order to integrate with the rest of the world of computer technology. *Encircle* is not meant to live on its own, but existing resources on the internet should be accessible, when working with the new language. Each integration module will facilitate two goals: accessing other systems using *Encircle* and the ability to access *Encircle* resources from inside other systems. As such you can access other file systems using *Encircle*, and you can also access *Encircle* resources as if it was a file system. That example would be called *File System Integration*. As such there will be systems such as *Database Integration*, *SOAP Integration*, *ODBC Integration*, *File Types* and *Module System Integration*. *Database Integration* will allow you to access *Encircle* as if it were relational database, but will also allow you to access relational database systems using *Encircle*. *SOAP Integration* will expose *Encircle* resources through a SOAP interface, but also allow you to access other SOAP interfaces using *Encircle*. *ODBC Integration* will make *Encircle* support connecting to it through ODBC, but will also allow you to access relational database resources using ODBC inside *Encircle*. *File Types* will allow you to export or expose *Encircle* resources as different commonly used file types, but also allows you to access files of such types from within *Encircle*. *Module System Integration* means, that you could for instance use ActiveX resources, Java, COM, .NET and other module systems using *Encircle*. Also, *Encircle* resources could be linked to as if they were for instance COM or any other module systems. Also, there will be *Protocols*, which will enable several internet protocols, so that you can access resources that are exposed through those protocols using Encircle. Protocols such as HTTP, SMTP, POP3, FTP, etcetera. It is considered quite important, that *Encircle* in the future will give access to all those resources as well as be accessible by other systems through all kinds of different protocols.

- ## [Artificial Intelligence, Natural Language, Neural Networks, Object Algebra](artificial-intelligence-natural-language-neural-networks-object-algebra.md)

    - It goes too far for now to consider the possibilities inside the new computer language regarding these concepts. But they are mentioned here, to demonstrate, that they are things that need to be thought about in the future. 

    - One of the sub-topics might be this:

        - __Object Algebra__

            - Object algebra is the concept of being able to math with the code, because the systematics of interconnections between objects might be as straightforward that it can be turned into a form of mathematics.

- ## [Automatic Object Formation](automatic-object-formation.md)

    - This is also a concept, that is considered to go too far for now. It is about automatically converting unorganized code and data into well-structured code and data, organizing it into objects, so that even when you would program something in an unstructured way, it can be automatically converted into a sound structure. This would be handy for trying to understand crap-code, or for reverse engineering compiled machine instructions, or to detect possible improvements to the structure of your code, maybe for deciphering the workings of a formed neural network. Maybe in the future you will not program in a structured way yourself anymore, but you just let the computer figure out the best way to structure the system. All in all, this goes too far for now, but it is something that needs to be thought through in the future.

- ## [Binaral](binaral.md)

    - *Binarals* might be analogous to *literals*. A literal may be a text representation of an object (for instance a literal number `3` or literal string `"Hi!"`). A binaral on the other hand, may be compiled computer code, or an object's data in a specific binary layout.

- ## [Debugging](debugging.md)

    - The new computer language is described, but how to go through code step by step or debug it has not been covered yet. This documentation may cover how debugging is implemented inside the environment of the new computer language. For now it only contains loose ideas about it. Nothing like this has been developed yet.

- ## [Fundamental Principles | Loose Ideas](fundamental-principles-loose-ideas.md)

    - Might contain loose ideas that might once be spread across "Exchangeability Principles", "Extensibility Principles" and "Achievability Principles".

- ## [Macro Recorder](macro-recorder.md)

    - The new computer language should have this button to press, that records all user actions, that are undertaken. Then, when you stop recording, the user actions are recorded as a procedure, that can be called as a command to be executed in one blow instead of performing all the actions manually. You can also edit the command code, to fine-tune the behavior of the command. This makes it easy to turn manual work into automatic procedures and it also makes it easier to program new commands. Other programs have this sort of macro recording, and the new computer language should also have such functionality in the futures. Macro recording has not been implemented inside existing versions of the new computer language yet.

- ### [Multiple Language Layers](multiple-language-layers.md)

    - Multiple language layers may be the idea that programming language could be built up of layers, first starting perhaps with *arithmetic* algebra and numbers (`+ - * /`). Arithmetic expressions may be input of *comparative* algebra (`< > =`). Then building up to *logical* operations (`and` / `or` / `not`). Then may follow *execution flow* (`if` / `else` / `then`). Constructs consisting of all of those operations may be organized into *procedures*. Those may be grouped into *objects*. Objects may have *relations* with each other. And what layer follows above that? *Aspects?* *Generated* code? From this idea might once follow a nice story. The document may just contain some loose ideas for now.
    
- ### [Object Storage](object-storage.md)

    - Object Storage may turn lists on storage devices into a landscape of digital objects. It might be the binding force between basic data structures on storage devices and the object logic of this computer language. It may be about how basic data structures are used to store objects. Not all of these principles might be original, because other systems might use them, but they were isolated here in a single place as a single group of concepts that may be used to turn storage into objects.
    
    - Perhaps trying to find one way to manage memory allocation, database-like storage and file systems might be a bit ambitious.
     
    - The documentation might not be finished. An attempt was made to sum up the required concepts trying to turn basic data structures into digital objects.

- ## [Text Classing](text-classing.md)

    - This concept might allow quickly selecting pieces of text out of a text document and call it an object and assign a class typing to it, so that you turn the text document into objects with classes, references to each other and a containment structure. That way text document might be turned into a relational structure perhaps in a practical way. The documentation tries to describes the basic idea.