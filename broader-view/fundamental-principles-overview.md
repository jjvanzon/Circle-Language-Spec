Circle Language Broader View | Fundamental Principles
=====================================================

Overview
--------

`[ Preliminary documentation ]`

This documentation describes the fundamental principles, upon which the new computer language is based. It covers the *reasons*, the *aims*  and the *way*  to realize the new computer language. Perhaps the most important goal of the new computer language, is to melt together all computer technology disciplines, providing one clear language, that can express anything, and that everybody can understand. The *Fundamental Principles* folder makes a lot of promises about the new language, but the *Coding Concepts* folder shows you how those promises are upheld.

This contents page will give a definition of each of the fundamental principles of the new computer language. More principles will be added in the future.

Most of these articles are not finished yet. The *Fundamental Principles*  folder contains the following articles:

### Exchangeability

The *Exchangeability Principles* describes things in the area of computer technology, that are traditionally separate, but will be combined to form one thing. The *Exchangeability* folder contains the following articles:

- #### Introduction

    - In the future this folder should contain an introduction to the exchangeability principles.

- #### Diagram & Text Code Expression

    - The idea is, that systematics can be fully expressed in text as well as in diagrams. The diagram code does not have anything missing it is: any aspect from the biggest outline to the finest detail can be clearly expressed with the diagram notation. The way storage of systematics as binary interlinked objects is separated from text code and diagram expression.

    - (This article is not finished yet.)

- #### Object Oriented = Relational

    - This article has not been written yet, but it should contain a description about how relational database is reconciled with object oriented programming. The two could always be combinedly used, but it has always been a problem to make the two really one system. They were always just two separate systems, that are conjoined. The new language will turn the two principles into a single paradigm. The object oriented approach and the relational database approach, which are traditionally separate things, are turned into one language. This is intrinsic to the new design of the language. It has not been fully established yet in the programmed versions of the new computer language.

- #### Data = Code

    - This fundamental principle is about the fact that a program will *not* consist of procedures operating on a database. Your program primarily is the database. Code is just inserted into the data structure, to become part of it.

- #### Programming Language = Database

    - This fundamental principle is about the fact that the code of a program is stored as a database. *Code is just data*, that describes a procedure.
     
    - This concept is fully applied inside the new design of the the computer language. It is not applied yet inside the running versions 0.9 and 2.0 of the new computer language.

- #### Design Time = Run Time

    - In most programming languages there is a distinction between design time and run time. This means, that the software is programmed first, and then run. You only run it after you programmed it. If the program it is not error free, the program may crash. The principle *Design Time = Run Time*  takes away this distinction between design time and run time. This article demonstrates how you can create a program and use it at the same time. It goes too much into what happens when an error occurs. That should be covered later in *Errors & Warnings* and in *Concurrency*.

    - The concept has not been fully realized yet in software, but version 2.0 of the new computer language comes close to it.

- #### User = Programmer

    - There is no distinction between design time and run time anymore. This makes programming software and using software blend together. Perhaps not everything will be easy to understand to every user, but the lines between creating a program and using a program will fade. The language, with which a user operates the computer, will be the same language, with which you program software. This article further goes into this concept.

- #### Clear Cut Coding Principles

    - The idea behind clear cut coding principles, is that the computer language is so accessible, that even children could pick it up, because the principles are so easy to understand, and there are not that many pitfalls. The basic parts of the coding principles could be picked up by anyone, but more advanced subjects need to be left out, because they can not be understood that easily. It is the intention for a running version of the new computer language to have sort of like a scale, a slider, that can be adjusted, limiting the amount of concepts expressed in the diagram or textual language, so that complex systems can be expressed using easier concepts, so that the general workings of a system are accessible to anyone.

- #### Attributes Are Objects

    - In traditional object oriented programming languages and relational databases simple data types, also called *attributes*, are not considered objects. They have such different behavior, that we tend to approach them much different from objects. In the new computer language, however, simple objects such as numbers and dates are always objects. There are a couple of special characteristics to *simple* objects, that will be explained in the *Objects* documentation. Unifying attributes with objects makes the new computer language’s grammar less complex.

    - (The article is not finished yet. It is just ideas gathered up out of old documentation, yet to be turned into a new article.)

- #### Command = Executable Object

    - Even more programming constructs are turned into just objects. Methods, functions, procedures, routines, commands, executables, all called *commands* in the new language, are actually objects too. Every command is a special object, that just happens to be executable. A whole chapter has been devoted to it: the *Commands* chapter. The differences between commands and normal objects are explained in it, but the essence of it is: commands are *objects*, *executable* *objects*. Turning commands and objects into the same construct makes the new computer language’s grammar less complex.

    - (This article is not started at yet.)

- #### Hand Signs

    - The diagram notation is so clear and expressive in its forms and shapes, that you can even draw out the shapes *in the air* to clarify systematics. The new computer language also is a hand sign language for technology.

    - (This article is not finished yet.)

- #### Hand Writing

    - Also: the diagrams can be drawn with a pencil on paper, so when you have a sheet of paper, you can also clarify the systematics of something using the diagram notation or draw out a quick sketch of systematics. However, a computer can more easily organize the diagram: you can quickly get a mess on a piece of paper, where a computer can automatically organize the diagram shapes.

    - (This article is not finished yet.)

- #### Hardware & Software

    - The new computer language will reveal the connection between object logic and the physical hardware. It will reveal the internal workings of a computer. It will connect logic to electronics.

    - (This folder contains no article yet.)

- #### System Engineering = Software Engineering

    - That way, the new computer language allows hardware and software developers and system engineers to work using the same language.

    - (This folder contains no article yet.)

- #### Internet as a Single Computer

    - This document describes how the internet is turned into a single computer. There simply is no difference between a program running on your own machine and programs running on another machine on the internet. The internet is just used as one giant computer, that everybody uses and contributes to.

    - This document has been moved to the *Infrastructure* documentation, because it will not be part of the first versions to come of the new computer language.

    - The documentation is quite lengthy and will later be split up into multiple pieces. No software has been developed for it yet.

- #### Hyperlinks = Referential Structure

    - This fundamental principle shows how to view hyperlinks in the new computer language. Hyperlinks are still part of a textual document, but they can also be seen as analogous to *object structures*, because they are about documents with references to other documents inside it, which is like objects with references to other objects inside it. So this fundamental principle explains how hyperlinks are exchangeable with referential structures, that can be visualized with the new computer language.

- #### Flat & Structured Interchange

    - The *Flat & Structured Interchange* principles are a set of principles, that turn something flat and unstructured into something branched out and structured. It also can approach anything structured as something entirely flat. Flat and structured are completely exchangeable. Some aspects of the system are not structured by a human being anymore. The system gets structured automatically. For instance: you can not control the containment structure of objects manually anymore. The containment structure is automatically derived from the referential structure of objects.

    - (This article is not finished yet.)

- #### User Interface Not Procedure Oriented

    - Programming interfaces have gone from procedural to object oriented. Procedures are part of an object, rather than separate procedures being executed on data. User interfaces, however, are still too much *procedure* oriented, because there are commands in a menu, instead of being able to right-click on an object and see any action you can undertake on it. Any command you can execute on an object should be listed under the context menu of that object. I first and foremost want to see a command hanging under an item, not look through a big list of commands to find the one, I can execute on my item. However, in the new system, all commands you can execute on an object, are accessible under the object itself. But also: all commands of all classes of objects are accessible as a flat list of commands. So the new system actually supports both views. Both views are exchangeable.

- #### Symbol = Creator

    - This principle partly confirms the *Object Oriented = Relational* principle. *Symbol*  refers to an object oriented programming language I began to construct around the year 2001. It is a programming language, that can fully express a program in a diagram. *Creator*  refers to a programming language I began working on around 2006. The basic principle of it is, that you start off defining classes and relations, and an application is generated out of it. The principle of *Symbol = Creator* is about turning these two languages into a single programming language. This is hard, because *Creator* is based on defining *relations*, and *Symbol* was an object oriented language about a diagram notation, which on top of it all had no way to express a *relation*. This article explains how the two will be combined in the new design, to form a single language.

### Extensibility

Another category of fundamental principles is the *extensibility principles*. Those cover the techniques that make sure existing software is easily extensible and making sure, that *Software System* integrates with the rest of the world of computer technology. *Software System* resources should be accessible to other systems and existing resources on the internet should be accessible in *Software System*. The *Extensibility* folder contains the following articles:

- #### Introduction

    - This folder is empty for now. In the future it should contain a description of what extensibility principles are.

- #### Reflection

    - Reflective data is data that describes the structure of a program. The reflective data of a program for instance contains descriptions of classes. In ordinary programming languages, it is considered something special to be able to access data that describes a program, listing out all the classes and all of its members. In the new computer language the program actually *is* a description of the structure of the program. As you make the program, you are creating this data, and it is actually the program itself, that will just be run inside an engine. Any object simply has a reference to its class. You can access the full description of this class at all times.

    - Having this reflective data at hand at all times, makes it easy to write software that adapts its behavior to this reflective data, rather than being written for a specific data structure. That creates better extensibility.

- #### Module Integration

    - In a newer version of computer language there is simply no distinction between modules anymore. It is like there is only one module running on the computer. Separate modules are simply sub-objects of one single module. An object can have a class out of any of the modules, that run on the computer or even a class out of any module on the internet.

    - Modules are not separate programs. They are just objects living inside the computer or on the internet. When a module contains an object with a class from another module, the object simply refers to the class as if there was not even any distinction between modules: everything is running on the same computer or on the same internet, everything is an object, and the modules are simply a benign grouping of things, that does not really create any barrier between programs.

- #### Concepts As External Modules

    - Concepts are power-enhancements of software, that can be immediately applied to any system without any further programming. A concept is a special programming construct.

    - A *concept* is close to what some programming environments call *aspects*. But concepts are supposed to be a richer, more usable variation on aspects.

    - Concepts allow you to program modules, that adapt themselves to the structure of other modules, automatically extending an existing structure with an extra aspect, such as instantly enabling copy-paste actions inside a system, that originally did not support it, or instantly being able to save object structures to XML, for a system that originally did not have this functionality.

    - Concepts will often make use of a system’s *reflective data*.

    - Turning concepts into external modules instead of polluting all the code of a program with it, makes systems more easily extensible.

    - This article is still just a throw-together of ideas, yet to be turned into good documentation.

- #### Relational As Carbon Base

    - The *Relational As Carbon Base* principle means that when making a program, you should primarily think in terms of relations between classes. The relations and classes are used as a base. They are used by *concepts*, for instance to automatically generate a user interface for the system. Also other concepts like *Undo* and *Copy & Paste* can automatically be applied to the relational structure. The concepts are tied to the relational structure. The relational structure forms the carbon base of the program, onto which other atom groups can be attached.

### Achievability

This sub-folder represents one of the three categories of fundamental principles: the achievability principles. The achievability principles are a set of principles, that describe how a new computer language can be developed in a limited amount of time with a limited amount of people: what techniques are employed to make that possible. It should also cover how the development of modules of *Software System* other than the programming language are made more achievable like that. The *Achievability* folder contains the following articles:

- #### Introduction

    - For now contains only loose ideas about the subject of *Achievability*, yet to be turned into good documentation.

- #### Generic, No Generators

    - Describes how the concept of code generators is abandoned and replaced by a better way to do it. The development of code generators is far more difficult, than an alternative method. The idea has been applied in realized software: version 2.0 of the new computer language compared to version 0.9 of the new computer language makes the transition from code generators to generic modules, that adapt themselves to a structure definition, that you assign to it. It makes it much easier to develop the new computer programming language, than when using the code generator approach.

- #### Small Code Base

    - This principle is about making the code base of the new computer language as small as possible and have the rest of the computer language programmed within the new computer language itself. This fundamental principle was also proven in version 2.0 of the new computer language: the code base was reprogrammed within itself.

- #### Computer Language Programmed Within Itself

    - The new computer language makes it easy to program large systems of software. But making the new computer language itself is hard. So the only way to easily make the new computer language, is to program the new computer language within the new computer language itself. This article tries to explain how this is possible. The description is lengthy and hard to understand. It covers too many technical details, instead of giving an easy presentation of the concept.

    - The concept *Computer Language Programmed Within Itself* has been proven with version 2.0 of the new computer language. In that version the base of the new language is actually reprogrammed using the new language itself. All other software can be based on that, which from then on is programmed only using the new computer language.

- #### Everything Only (Lack Of Choice = Guarantees)

    - In version 0.9 of the new computer language almost any part of the code, that was generated, was optional. This basically created a lot of different possible situations in which everything needed to still function correctly. The principle of *Everything Only* is the opposite: instead of making everything optional, everything is included without a choice. This limits all the possible situations, which makes things easier to test, there are no surprises and it is easy to give guarantees about a system’s functioning. This principle is not applied to every situation, but it can be applied selectively to make things easier to achieve: just do not make too many things optional. That will minimize the amount of possible situations.

    - This article covers the why and where it went wrong before. It is explained why this principle was come up with, but this makes it harder to read, because it is not enough a raw description of the concept. It may give you an impression of: “Why do I need to know all this? Why are you bothering me with all of this background information?”.

- #### C++ / C\#

    - This principle constitutes the mere fact, that the code base of the new computer language will initially be programmed using C++ or C#. It is called an achievability principle, because originally the new computer language was written in VB6 and this created a great performance barrier. Version 2.0 of the new computer language is based on C++. Version 3 of the new computer language will be based on C# and .NET.