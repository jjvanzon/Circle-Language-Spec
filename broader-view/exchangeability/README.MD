Encircle Language | Broader View
==============================

Exchangeability
---------------

`[ Preliminary documentation ]`

The *Exchangeability Principles* describes things in the area of computer technology, that are traditionally separate, that might be combined to form one thing.

Perhaps a central goal of the Encircle programming language might be, to melt together computer technology disciplines, aiming to provide one clear language, that might express anything, and that everybody might understand. The *Extensibility Principles* may give shape to these hopes for the language.

This contents page will try to give a definition of each of the exchangeability principles of Encircle programming language. More principles might be added in the future.

Some of these articles are not finished yet. The *Exchangeability Principles* folder may contain the following articles:

- ### [Diagram & Text Code Expression](diagram-and-text-code-expression.md)

    - The idea is, that systematics can be fully expressed in text as well as in diagrams. The diagram code does not have anything missing it is: any aspect from the biggest outline to the finest detail can be clearly expressed with the diagram notation. The way storage of systematics as binary interlinked objects is separated from text code and diagram expression.

    - (This article is not finished yet.)

- ### Object Oriented = Relational

    - This article has not been written yet, but it should contain a description about how relational database is reconciled with object oriented programming. The two could always be combinedly used, but it has always been a problem to make the two really one system. They were always just two separate systems, that are conjoined. The new language will turn the two principles into a single paradigm. The object oriented approach and the relational database approach, which are traditionally separate things, are turned into one language. This is intrinsic to the new design of the language. It has not been fully established yet in the programmed versions of the new computer language.

    - (There may not be a separate article for this yet.)

- ### [Data = Code](data-is-code.md)

    - This fundamental principle is about the fact that a program will *not* consist of procedures operating on a database. Your program primarily is the database. Code is just inserted into the data structure, to become part of it.

- ### [Programming Language = Database](programming-language-is-database.md)

    - This fundamental principle is about the fact that the code of a program is stored as a database. *Code is just data*, that describes a procedure.
     
    - This concept is fully applied inside the new design of the the computer language. It is not applied yet inside the running versions 0.9 and 2.0 of the new computer language.

- ### [Design Time = Run Time](design-time-is-run-time.md)

    - In most programming languages there is a distinction between design time and run time. This means, that the software is programmed first, and then run. You only run it after you programmed it. If the program it is not error free, the program may crash. The principle *Design Time = Run Time*  takes away this distinction between design time and run time. This article demonstrates how you can create a program and use it at the same time. It goes too much into what happens when an error occurs. That should be covered later in *Errors & Warnings* and in *Concurrency*.

    - The concept has not been fully realized yet in software, but version 2.0 of the new computer language comes close to it.

- ### [User = Programmer](user-is-programmer.md)

    - There is no distinction between design time and run time anymore. This makes programming software and using software blend together. Perhaps not everything will be easy to understand to every user, but the lines between creating a program and using a program will fade. The language, with which a user operates the computer, will be the same language, with which you program software. This article further goes into this concept.

- ### [Clear Cut Coding Principles](clear-cut-coding-principles.md)

    - The idea behind clear cut coding principles, is that the computer language is so accessible, that even children could pick it up, because the principles are so easy to understand, and there are not that many pitfalls. The basic parts of the coding principles could be picked up by anyone, but more advanced subjects need to be left out, because they can not be understood that easily. It is the intention for a running version of the new computer language to have sort of like a scale, a slider, that can be adjusted, limiting the amount of concepts expressed in the diagram or textual language, so that complex systems can be expressed using easier concepts, so that the general workings of a system are accessible to anyone.

- ### [Attributes Are Objects](attributes-are-objects.md)

    - In traditional object oriented programming languages and relational databases simple data types, also called *attributes*, are not considered objects. They have such different behavior, that we tend to approach them much different from objects. In the new computer language, however, simple objects such as numbers and dates are always objects. There are a couple of special characteristics to *simple* objects, that will be explained in the *Objects* documentation. Unifying attributes with objects makes the new computer language’s grammar less complex.

    - (The article is not finished yet. It is just ideas gathered up out of old documentation, yet to be turned into a new article.)

- ### [Command = Executable Object](command-is-executable-object.md)

    - Even more programming constructs are turned into just objects. Methods, functions, procedures, routines, commands, executables, all called *commands* in the new language, are actually objects too. Every command is a special object, that just happens to be executable. A whole chapter has been devoted to it: the *Commands* chapter. The differences between commands and normal objects are explained in it, but the essence of it is: commands are *objects*, *executable* *objects*. Turning commands and objects into the same construct makes the new computer language’s grammar less complex.

    - (This article is not started at yet.)

- ### [Hand Signs](hand-signs.md)

    - The diagram notation is so clear and expressive in its forms and shapes, that you can even draw out the shapes *in the air* to clarify systematics. The new computer language also is a hand sign language for technology.

    - (This article is not finished yet.)

- ### [Hand Writing](hand-writing.md)

    - Also: the diagrams can be drawn with a pencil on paper, so when you have a sheet of paper, you can also clarify the systematics of something using the diagram notation or draw out a quick sketch of systematics. However, a computer can more easily organize the diagram: you can quickly get a mess on a piece of paper, where a computer can automatically organize the diagram shapes.

    - (This article is not finished yet.)

- ### Hardware & Software

    - The new computer language will reveal the connection between object logic and the physical hardware. It will reveal the internal workings of a computer. It will connect logic to electronics.

    - (There may not be a separate article for this yet.)
    
- ### System Engineering = Software Engineering

    - That way, the new computer language allows hardware and software developers and system engineers to work using the same language.

    - (There may not be a separate article for this yet.)

- ### [Internet as a Single Computer](internet-as-a-single-computer.md)

    - This document describes how the internet is turned into a single computer. There simply is no difference between a program running on your own machine and programs running on another machine on the internet. The internet is just used as one giant computer, that everybody uses and contributes to.

    - This document has been moved to the *Infrastructure* documentation, because it will not be part of the first versions to come of the new computer language.

    - The documentation is quite lengthy and will later be split up into multiple pieces. No software has been developed for it yet.

- ### [Hyperlinks = Referential Structure](hyper-links-is-referential-structure.md)

    - This fundamental principle shows how to view hyperlinks in the new computer language. Hyperlinks are still part of a textual document, but they can also be seen as analogous to *object structures*, because they are about documents with references to other documents inside it, which is like objects with references to other objects inside it. So this fundamental principle explains how hyperlinks are exchangeable with referential structures, that can be visualized with the new computer language.

- ### [Flat & Structured Interchange Loose Ideas](flat-and-structured-interchange-loose-ideas.md)

    - The *Flat & Structured Interchange* principles are a set of principles, that turn something flat and unstructured into something branched out and structured. It also can approach anything structured as something entirely flat. Flat and structured are completely exchangeable. Some aspects of the system are not structured by a human being anymore. The system gets structured automatically. For instance: you can not control the containment structure of objects manually anymore. The containment structure is automatically derived from the referential structure of objects.

    - (This article is not finished yet.)

- ### [User Interface Not Procedure Oriented](user-interface-not-procedure-oriented.md)

    - Programming interfaces have gone from procedural to object oriented. Procedures are part of an object, rather than separate procedures being executed on data. User interfaces, however, are still too much *procedure* oriented, because there are commands in a menu, instead of being able to right-click on an object and see any action you can undertake on it. Any command you can execute on an object should be listed under the context menu of that object. I first and foremost want to see a command hanging under an item, not look through a big list of commands to find the one, I can execute on my item. However, in the new system, all commands you can execute on an object, are accessible under the object itself. But also: all commands of all classes of objects are accessible as a flat list of commands. So the new system actually supports both views. Both views are exchangeable.

- ### [Symbol = Creator](symbol-is-creator.md)

    - This principle partly confirms the *Object Oriented = Relational* principle. *Symbol*  refers to an object oriented programming language I began to construct around the year 2001. It is a programming language, that can fully express a program in a diagram. *Creator*  refers to a programming language I began working on around 2006. The basic principle of it is, that you start off defining classes and relations, and an application is generated out of it. The principle of *Symbol = Creator* is about turning these two languages into a single programming language. This is hard, because *Creator* is based on defining *relations*, and *Symbol* was an object oriented language about a diagram notation, which on top of it all had no way to express a *relation*. This article explains how the two will be combined in the new design, to form a single language.

- ### [Exchangeability Loose Ideas](exchangeability-loose-ideas.md)

    - Loose ideas not yet given a place.