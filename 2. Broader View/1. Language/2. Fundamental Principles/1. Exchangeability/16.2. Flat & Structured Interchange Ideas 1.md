Flat & Structured Interchange 
=============================

*Date: 2005-08-31*

## ***Flat & Structured Interchange***

\- Automatic Containment

\- Commands & Classes Loosely Coupled

\- Automatic Execution Order

\- Automatic Determination Parameter In / Out / Thru

\- Attributes As Tree Layers

\- Automatic Object Formation

## ***Ideas***

*These were moved here from the Projects documentation, to the System documentation, to integrate them with the System documentation. Remaining ideas should be moved back to the Projects documentation after that. The Projects documentation is where Ideas belong.*




Because of the exchangability of global members and class members, a global function can boldly add a member to a class if one of its parameters is of this class and assigned to be the class to be extended.


Ik had het vanmiddag met Arthur over het probleem dat

bijvoorbeeld neurale netwerken niet controleerbaar zijn, omdat

alles een platte structuur van schakelingen is, waar geen

groepering in kan worden gezien door een mens.

En ik had het erover dat de controle misschien wel groter was als

er een systeem was dat dit om kan zetten in groepering.

Met Creator's manier om referentieel naar encapsulatief om te zetten, zou

hier wel uitkomsten voor kunnen bieden.

Echter, herhalende patronen moeten ook in klassen worden omgezet.

Crea:

Ook de procedure structuur kan van referentiele structuur naar encapsulatief worden omgezet. Je kunt dan ook bepaalde lagen onderscheiden in de procedures binnen 1 class.

Complete interchangability between flat

and structured.

Next to autoencapsulation, you could also

make automatic hierarchical subdivision by class attributes a common thing. That way unstructured and structured become more interchangable.

The table approach is actually the unstructured approach, but it interchanges with.

Here I am searching for methods that make completely unstructured completely translate to completely structured without human intervention.

Because that could be the tool to make Sy and Cre a single language. The same counts for how the symbols are positioned on screen by Sy, and how text code is displayed in a structured manner.

Cool, but a long way to go.





\- 2008-03-28  A new twist to Flat & Structured Interchange is that objects on a deep level are no longer subdivised into classes. Each object is an individual, with an arbitrary number of attributes, related items and related lists. The classes of the related items and related lists don’t even need to be fixed, they are just items or lists that hold references to any other arbitrary object. This creates even more extra flatness compared to a system where a class results in its own set of files.

I won’t brainstorm too much here, but funny enough, an object then holds an list with an arbitrary amount of attributes, a list with an arbitrary amount of related items, and a list with an arbitrary amount of lists. *Everything* has become a little list which can individually scale. This has implications for how I’m going to realize something disk based. I won’t have a file for each attribute of a class anymore.

I need to look for a different way in which to store things on disk. Either I pack many small lists into a single space somehow, or I just insist to create a new space for each little list, but this could become costly, depending on the block size.
PAGE  3

